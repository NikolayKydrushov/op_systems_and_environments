# Лаболаторные работы

## Описание:
В данном проекте содержатся все готовые лаболаторные работы по дисциплине "Операционные системы с среды". Каждая ветка в данном пректе отдельная лаба, каждый коммит - отдельное задание в данной лаболаторной работе. В README содержатся все необходимые навыки для данной лабы.

## Использование:

### Лаба 5:

#### Задание 1
##### 1. Компилирование программ с помощью gcc.
GCC (GNU Compiler Collection) - Основной компилятор в Linux-системах.
Clang - Современный компилятор с лучшими диагностическими сообщениями.

Процесс компиляции:
* Препроцессинг - процесс преобразования исходного кода программы, написанной на одном языке программирования, в эквивалентную программу на другом языке, достигается с помощью специального программного обеспечения — препроцессора.
  - ```gcc -E program.c -o program.i```
  - Обрабатывает директивы #include, #define
  - Раскрывает макросы
  - Удаляет комментарии
* Компиляция - процесс преобразования исходного кода программы, написанного на языке программирования высокого уровня, в машинный код, который может быть выполнен процессором, осуществляется с помощью специальной программы — компилятора.
  - ```gcc -S program.c -o program.s```
  - Преобразует C-код в ассемблер
  - Проверяет синтаксис и семантику
* Ассемблирование - трансляции программы с языка ассемблера в машинный код. Ассемблер — программа, которая преобразует исходный код на языке ассемблера в машинный код, понятный процессору.
  - ```gcc -c program.c -o program.o```
  - Преобразует ассемблер в объектный код
  - Создает relocatable object files
* Линковка - процесс объединения всех объектных файлов, сгенерированных компилятором, в один исполняемый (или библиотечный) файл. 
  - ```gcc program.o -o program```
  - Объединяет объектные файлы
  - Разрешает внешние ссылки
  - Создает исполняемый файл

Ключевые флаги компиляции:
  * Флаги предупреждений:
    - ```gcc -Wall -Wextra -Wpedantic program.c```
    - -Wall - включить все основные предупреждения
    - -Wextra - дополнительные предупреждения
    - -Wpedantic - строгое соответствие стандарту
    - -Werror - трактовать предупреждения как ошибки
  * Флаги отладки:
    - ```gcc -g -O0 program.c```
    - -g - добавить отладочную информацию
    - -O0 - отключить оптимизацию (для отладки)
    - -ggdb - расширенная отладочная информация для GDB


##### 2. Состояние гонки.
Cостояние гонки - это ошибка проектирования, когда поведение системы зависит от относительного порядка выполнения операций в параллельных процессах/потоках.
Недетерминированность - результат зависит от времени, а не только от входных данных
Воспроизводимость - может проявляться не при каждом запуске

Базовый сценарий возникновения:
```
Поток A: Прочитать значение X (X = 5)
Поток B: Прочитать значение X (X = 5)
Поток A: Увеличить X (X = 6)
Поток B: Увеличить X (X = 6)  # Должно быть 7!
```

Условия для гонки:
  * Параллельный доступ - минимум два потока/процесса
  * Разделяемый ресурс - общая память, файл, переменная
  * Изменение состояния - хотя бы один поток изменяет ресурс
  * Отсутствие синхронизации - нет механизмов координации доступа


##### 3. Критическая секция.
Критическая секция - часть программы, в которой осуществляется доступ к разделяемому ресурсу
Требует взаимного исключения - только один поток может находиться в критической секции
Цель - предотвращение состояний гонки

Свойства правильной реализации:
  * Взаимное исключение (Mutual Exclusion):
    - Только один поток может выполнять критическую секцию в любой момент
    - Другие потоки блокируются до освобождения секции
  * Прогресс (Progress):
    - Если критическая секция свободна, то поток должен получить к ней доступ
    - Не должно быть бесконечного ожидания при свободной секции
  * Ограниченное ожидание (Bounded Waiting):
    - Существует верхняя граница времени ожидания для любого потока
    - Предотвращение голодания (starvation) потоков


##### 4. POSIX threads: как создавать, как дожидаться завершения.
Потоки (threads) vs Процессы:
  * Потоки - легковесные исполняемые единицы в рамках процесса
  * Общая память - все потоки разделяют адресное пространство
  * Раздельные - стеки, регистры, состояние выполнения

Преимущества потоков:
  * Быстрое создание/уничтожение
  * Эффективная коммуникация через общую память
  * Меньшие накладные расходы на переключение контекста

Жизненный цикл: 
Создан → Выполняется → Блокирован → Выполняется → Завершен


##### 5. Как линковаться на бибилотеку pthread
Компиляция и линковка:
```gcc -pthread -o program program.c```

Различия флагов:
  * lpthread:
    - Только линковка с библиотекой pthread
    - Может не устанавливать правильные макросы препроцессора
  * pthread:
    - Определяет макросы (_REENTRANT) для thread-safe кода
    - Устанавливает флаги для корректной работы потоков
    - Рекомендуется для переносимости

Позиция флага:
  * lpthread должен быть после исходных файлов
  * pthread можно в любом месте командной строки
```
# Правильно
gcc -pthread -o program program.c
gcc program.c -o program -lpthread

# Неправильно (может не слинковаться)
gcc -lpthread -o program program.c
```



#### Задание 2
##### 1. POSIX threads: как создавать, как дожидаться завершения.


##### 2. Как линковаться на бибилотеку pthread


##### 3. Как использовать мьютексы.
Мьютекс (mutual exclusion) - примитив синхронизации, обеспечивающий взаимное исключение доступа к разделяемому ресурсу
Бинарный семафор - может находиться в одном из двух состояний: заблокирован или разблокирован
Владелец - поток, который захватил мьютекс, должен его освободить

Основные операции:
  * Инициализация:
    - Статическая инициализация значениями по умолчанию
    - Динамическая инициализация с атрибутами
    - Уничтожение - освобождение ресурсов мьютекса
  * Захват и освобождение:
    - Lock (захват) - попытка завладеть мьютексом, блокировка если занят
    - Unlock (освобождение) - освобождение мьютекса для других потоков
    - Trylock - неблокирующая попытка захвата



#### Задание 3
##### 1. Состояние deadlock
Deadlock - ситуация, когда два или более потока заблокированы навсегда, каждый ожидает ресурс, удерживаемый другим
Тупиковая ситуация - отсутствие прогресса в системе
Неразрешима без внешнего вмешательства

Пример deadlock:
```
Поток A: Захватить мьютекс X
Поток B: Захватить мьютекс Y
Поток A: Попытаться захватить мьютекс Y (блокируется)
Поток B: Попытаться захватить мьютекс X (блокируется)
→ DEADLOCK
```
