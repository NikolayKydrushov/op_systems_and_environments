# Лаболаторные работы

## Описание:
В данном проекте содержатся все готовые лаболаторные работы по дисциплине "Операционные системы с среды". Каждая ветка в данном пректе отдельная лаба, каждый коммит - отдельное задание в данной лаболаторной работе. В README содержатся все необходимые навыки для данной лабы.

## Использование:

### Лаба 4:

#### Задание 1

##### 1. Функция kill

Основные концепции:
  * Отправка сигналов процессам или группам процессов
  * Не убивает обязательно - название историческое
  * Сигналы - это software interrupts для межпроцессного взаимодействия
  * PID определяет целевой процесс: >0 конкретный процесс, 0 - группа, -1 - все процессы (с ограничениями), <-1 - группа процессов

Типы сигналов:
  * Завершение: SIGTERM (15) - корректное завершение, SIGKILL (9) - принудительное
  * Остановка: SIGSTOP (остановка), SIGCONT (продолжение)
  * Пользовательские: SIGUSR1, SIGUSR2 - для кастомной логики
  * Ошибки: SIGSEGV (segmentation fault), SIGILL (illegal instruction)

Права доступа:
  * Отправитель и получатель должны иметь одинаковый UID (или отправитель root)
  * Исключение: SIGCONT для процессов в одной сессии


##### 2. Неблокирующий wait c WNOHANG

Основные концепции:
  * wait - ожидание изменения состояния дочернего процесса
  * Блокирующий wait приостанавливает выполнение родителя
  * WNOHANG - неблокирующий режим, немедленный возврат
  * Состояния: завершен (exited), остановлен (stopped), продолжил (continued)

Поведение с WNOHANG:
  * Немедленный возврат если нет изменений в дочерних процессах
  * Возвращает PID дочернего процесса если состояние изменилось
  * Возвращает 0 если дочерние процессы существуют, но не изменили состояние
  * Возвращает -1 если дочерних процессов нет

Использование:
  * Циклы опроса для мониторинга группы процессов
  * Кооперативная многозадачность в одном процессе
  * Graceful shutdown - проверка завершения дочерних процессов


##### 3. Функция alarm, сигнал SIGALRM, функция signal.

Функция alarm:
  * Установка таймера на указанное количество секунд
  * Одновременно только один активный alarm
  * Возвращает оставшееся время предыдущего alarm
  * 0 секунд - отмена предыдущего alarm
  * Доставка SIGALRM при срабатывании
  * Особенности:
    - Не точное время - задержки из-за планировщика
    - Не повторяется автоматически
    - Перезапуск - нужно вызывать alarm повторно в обработчике

Сигнал SIGALRM:
  * По умолчанию завершает процесс
  * Используется для таймаутов и периодических задач
  * Не накапливается - только один ожидающий SIGALRM
  * Особенности:
    - Не точное время - задержки из-за планировщика
    - Не повторяется автоматически
    - Перезапуск - нужно вызывать alarm повторно в обработчике

Функция signal:
  * Установка обработчиков для сигналов
  * Обработчик - функция вызываемая при получении сигнала
  * Три способа обработки: игнорировать, по умолчанию, пользовательский обработчик
  * Особенности обработчиков:
    - Асинхронный вызов - в любой момент выполнения программы
    - Переустановка - некоторые обработчики сбрасываются после вызова
    - Безопасные функции - только async-signal-safe функции в обработчиках
    - Маскировка сигналов - во время выполнения обработчика тот же сигнал блокируется



#### Задание 2

##### 1. Что такое зомби процессы, как появляются, как исчезают.
Зомби-процесс (zombie) - это процесс, который завершил выполнение, но еще не был "уборен" своим родительским процессом
Процесс выполнил системный вызов exit() или получил фатальный сигнал. Ядро освободило все ресурсы процесса (память, файлы и т.д.). Но сохранило запись в таблице процессов с статусом завершения. Запись сохраняется до тех пор, пока родительский процесс не прочитает статус

Механизм создания:
  * Дочерний процесс завершается (exit, фатальный сигнал)
  * Ядро отправляет SIGCHLD родительскому процессу (если не игнорируется)
  * Родитель не вызывает wait()/waitpid() для чтения статуса
  * Запись процесса сохраняется в таблице процессов как зомби

Как исчезают зомби-процессы:
  * Родитель вызывает wait()/waitpid()
  * Ядро удаляет запись из таблицы процессов
  * PID освобождается для повторного использования



#### Задание 3

##### 1. Работа виртуальной памяти.

Виртуальная память - абстракция, которую видит процесс
Физическая память - реальные ячейки RAM

Адресное пространство процесса:
```
0x00000000-0x08048000: Зарезервировано
0x08048000-0x08049000: Текст (код)
0x08049000-0x0804a000: Данные (инициализированные)
0x0804a000-0x0804b000: BSS (неинициализированные данные)
0xbfxxxxxx-0xbfffffff: Стек
Динамическая область: Куча (heap)
```

Сегменты памяти:
  * Текст (text) - исполняемый код, read-only
  * Данные (data) - инициализированные глобальные переменные
  * BSS - неинициализированные глобальные переменные (обнуляются)
  * Куча (heap) - динамическая память (malloc/free)
  * Стек (stack) - локальные переменные, вызовы функций

Преимущества виртуальной памяти:
  * Каждый процесс имеет собственное адресное пространство
  * Невозможно случайно повредить память другого процесса
  * Безопасность и стабильность системы
  * Copy-on-Write - страницы копируются только при изменении
  * Shared memory - общие библиотеки в памяти
  * Memory mapping - файлы отображаются в память



#### Задание 5

##### 1. POSIX threads: как создавать, как дожидаться завершения.
Потоки (threads) vs Процессы:
  * Потоки - легковесные исполняемые единицы в рамках процесса
  * Общая память - все потоки разделяют адресное пространство
  * Раздельные - стеки, регистры, состояние выполнения

Преимущества потоков:
  * Быстрое создание/уничтожение
  * Эффективная коммуникация через общую память
  * Меньшие накладные расходы на переключение контекста

Жизненный цикл: 
Создан → Выполняется → Блокирован → Выполняется → Завершен


##### 2. Как линковаться на бибилотеку pthread
Компиляция и линковка:
```gcc -pthread -o program program.c```

Различия флагов:
  * lpthread:
    - Только линковка с библиотекой pthread
    - Может не устанавливать правильные макросы препроцессора
  * pthread:
    - Определяет макросы (_REENTRANT) для thread-safe кода
    - Устанавливает флаги для корректной работы потоков
    - Рекомендуется для переносимости

Позиция флага:
  * lpthread должен быть после исходных файлов
  * pthread можно в любом месте командной строки
```
# Правильно
gcc -pthread -o program program.c
gcc program.c -o program -lpthread

# Неправильно (может не слинковаться)
gcc -lpthread -o program program.c
```
